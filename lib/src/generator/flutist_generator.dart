import 'dart:io';

import '../core/core.dart';
import '../utils/utils.dart';

/// Generator for flutist_gen.dart file.
class GenFileGenerator {
  /// Generates the flutist_gen.dart file based on package.dart.
  /// If [projectModuleNames] is provided, only modules present in project.dart will be included.
  static void generate(String rootPath, {List<String>? projectModuleNames}) {
    try {
      Logger.info('Generating flutist_gen.dart...');

      // Parse package.dart
      final packageFile = File('$rootPath/package.dart');

      if (!packageFile.existsSync()) {
        Logger.warn('package.dart not found. Skipping gen file generation.');
        return;
      }

      final content = packageFile.readAsStringSync();
      final package = _parsePackageDart(content);

      // Filter modules if projectModuleNames is provided
      final filteredPackage = projectModuleNames != null
          ? _filterPackageModules(package, projectModuleNames)
          : package;

      // Create flutist directory if not exists
      final flutistDir = Directory('$rootPath/flutist');
      if (!flutistDir.existsSync()) {
        flutistDir.createSync(recursive: true);
      }

      // Generate content
      final genContent = _buildGenContent(filteredPackage);

      // Write to file
      final genFile = File('$rootPath/flutist/flutist_gen.dart');
      genFile.writeAsStringSync(genContent);

      Logger.success('Generated flutist_gen.dart');
    } catch (e) {
      Logger.error('Failed to generate flutist_gen.dart: $e');
    }
  }

  /// Filters package modules to only include those present in project.dart.
  static Package _filterPackageModules(
      Package package, List<String> projectModuleNames) {
    final filteredModules = package.modules
        .where((module) => projectModuleNames.contains(module.name))
        .toList();

    return Package(
      name: package.name,
      dependencies: package.dependencies,
      modules: filteredModules,
    );
  }

  /// Parses package.dart content.
  static Package _parsePackageDart(String content) {
    // Parse package name
    final nameMatch = RegExp(r"name:\s*'([^']+)'").firstMatch(content);
    final packageName = nameMatch?.group(1) ?? 'workspace';

    // Parse dependencies
    final dependencies = _parseDependencies(content);

    // Parse modules
    final modules = _parseModules(content);

    return Package(
      name: packageName,
      dependencies: dependencies,
      modules: modules,
    );
  }

  /// Parses dependencies from package.dart content.
  static List<Dependency> _parseDependencies(String content) {
    final dependencies = <Dependency>[];

    final dependenciesPattern = RegExp(
      r'dependencies:\s*\[(.*?)\]',
      dotAll: true,
    );
    final match = dependenciesPattern.firstMatch(content);

    if (match == null) return dependencies;

    final dependenciesContent = match.group(1)!;

    final dependencyPattern = RegExp(
      r"Dependency\s*\(\s*name:\s*'([^']+)'\s*,\s*version:\s*'([^']+)'\s*\)",
    );

    for (final depMatch in dependencyPattern.allMatches(dependenciesContent)) {
      final name = depMatch.group(1)!;
      final version = depMatch.group(2)!;
      dependencies.add(Dependency(name: name, version: version));
    }

    return dependencies;
  }

  /// Parses modules from package.dart content.
  static List<Module> _parseModules(String content) {
    final modules = <Module>[];

    final modulesPattern = RegExp(
      r'modules:\s*\[(.*?)\]',
      dotAll: true,
    );
    final match = modulesPattern.firstMatch(content);

    if (match == null) return modules;

    final modulesContent = match.group(1)!;

    final modulePattern = RegExp(
      r"Module\s*\(\s*name:\s*'([^']+)'\s*,\s*type:\s*ModuleType\.(\w+)\s*\)",
    );

    for (final modMatch in modulePattern.allMatches(modulesContent)) {
      final name = modMatch.group(1)!;
      final typeString = modMatch.group(2)!;
      final type = _parseModuleType(typeString);
      modules.add(Module(name: name, type: type));
    }

    return modules;
  }

  /// Builds the content for flutist_gen.dart.
  static String _buildGenContent(Package package) {
    final buffer = StringBuffer();

    // Header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by Flutist');
    buffer.writeln();
    buffer.writeln("import 'package:flutist/flutist.dart';");
    buffer.writeln();

    // Dependencies Extension
    buffer.writeln('/// Extension for package.dependencies.xxx access');
    buffer.writeln('extension PackageDependenciesX on List<Dependency> {');

    for (final dep in package.dependencies) {
      final getterName = _toCamelCase(dep.name);
      buffer.writeln("  /// Dependency getter for ${dep.name}");
      buffer.writeln(
          "  Dependency get $getterName => firstWhere((d) => d.name == '${dep.name}');");
    }

    buffer.writeln('}');
    buffer.writeln();

    // Modules Extension
    buffer.writeln('/// Extension for package.modules.xxx access');
    buffer.writeln('extension PackageModulesX on List<Module> {');

    for (final module in package.modules) {
      final getterName = _toCamelCase(module.name);
      buffer.writeln("  /// Module getter for ${module.name}");
      buffer.writeln(
          "  Module get $getterName => firstWhere((m) => m.name == '${module.name}');");
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  /// Converts snake_case to camelCase.
  static String _toCamelCase(String snakeCase) {
    final parts = snakeCase.split('_');
    if (parts.length == 1) return snakeCase;

    final first = parts.first;
    final rest = parts.skip(1).map((part) {
      if (part.isEmpty) return part;
      return part[0].toUpperCase() + part.substring(1);
    });

    return first + rest.join('');
  }

  /// Converts string to ModuleType enum.
  static ModuleType _parseModuleType(String typeString) {
    switch (typeString) {
      case 'feature':
        return ModuleType.feature;
      case 'library':
        return ModuleType.library;
      case 'standard':
        return ModuleType.standard;
      case 'simple':
        return ModuleType.simple;
      default:
        throw ArgumentError('Invalid module type: $typeString');
    }
  }
}
