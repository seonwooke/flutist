import 'dart:io';

import '../core/core.dart';
import '../utils/utils.dart';
import 'commands.dart';

class GenerateCommand implements BaseCommand {
  @override
  String get name => 'generate';

  @override
  String get description =>
      'Sync all pubspec.yaml files based on project.dart.';

  @override
  void execute(List<String> arguments) {
    Logger.info('Starting Flutist generation...');

    try {
      final currentDir = Directory.current.path;

      // Step 1: Parse package.dart
      final packageData = _parsePackageDart(currentDir);

      if (packageData == null) {
        Logger.error('Failed to parse package.dart');
        exit(1);
      }

      Logger.success('Parsed package.dart');
      Logger.info('  Dependencies: ${packageData.dependencies.length}');
      Logger.info('  Modules: ${packageData.modules.length}');

      // Step 2: Generate flutist_gen.dart
      _generateFlutistGen(currentDir, packageData);

      // TODO: Step 3: Parse project.dart
      // TODO: Step 4: Update pubspec.yaml files

      Logger.success('Generation completed!');
    } catch (e) {
      Logger.error('Generation failed: $e');
      exit(1);
    }
  }

  /// Parses the package.dart file.
  /// package.dart 파일을 파싱합니다.
  Package? _parsePackageDart(String currentDir) {
    Logger.info('Parsing package.dart...');

    final packageFile = File('$currentDir/package.dart');

    if (!packageFile.existsSync()) {
      Logger.error('package.dart not found');
      return null;
    }

    try {
      final content = packageFile.readAsStringSync();

      // Parse package name
      final nameMatch = RegExp(r"name:\s*'([^']+)'").firstMatch(content);
      final packageName = nameMatch?.group(1) ?? 'workspace';

      // Parse dependencies
      final dependencies = _parseDependencies(content);

      // Parse modules
      final modules = _parseModules(content);

      return Package(
        name: packageName,
        dependencies: dependencies,
        modules: modules,
      );
    } catch (e) {
      Logger.error('Failed to parse package.dart: $e');
      return null;
    }
  }

  /// Parses dependencies from package.dart content.
  /// package.dart 내용에서 dependencies를 파싱합니다.
  List<Dependency> _parseDependencies(String content) {
    final dependencies = <Dependency>[];

    // Find dependencies array
    final dependenciesPattern = RegExp(
      r'dependencies:\s*\[(.*?)\]',
      dotAll: true,
    );
    final match = dependenciesPattern.firstMatch(content);

    if (match == null) return dependencies;

    final dependenciesContent = match.group(1)!;

    // Find each Dependency(...) entry
    final dependencyPattern = RegExp(
      r"Dependency\s*\(\s*name:\s*'([^']+)'\s*,\s*version:\s*'([^']+)'\s*\)",
    );

    for (final depMatch in dependencyPattern.allMatches(dependenciesContent)) {
      final name = depMatch.group(1)!;
      final version = depMatch.group(2)!;

      dependencies.add(Dependency(name: name, version: version));
    }

    return dependencies;
  }

  /// Parses modules from package.dart content.
  /// package.dart 내용에서 modules를 파싱합니다.
  List<Module> _parseModules(String content) {
    final modules = <Module>[];

    // Find modules array
    final modulesPattern = RegExp(
      r'modules:\s*\[(.*?)\]',
      dotAll: true,
    );
    final match = modulesPattern.firstMatch(content);

    if (match == null) return modules;

    final modulesContent = match.group(1)!;

    // Find each Module(...) entry
    final modulePattern = RegExp(
      r"Module\s*\(\s*name:\s*'([^']+)'\s*,\s*type:\s*ModuleType\.(\w+)\s*\)",
    );

    for (final modMatch in modulePattern.allMatches(modulesContent)) {
      final name = modMatch.group(1)!;
      final typeString = modMatch.group(2)!;
      final type = _parseModuleType(typeString);

      modules.add(Module(name: name, type: type));
    }

    return modules;
  }

  /// Generates the flutist_gen.dart file.
  /// flutist_gen.dart 파일을 생성합니다.
  void _generateFlutistGen(String currentDir, Package package) {
    Logger.info('Generating flutist_gen.dart...');

    // Create flutist directory if not exists
    final flutistDir = Directory('$currentDir/flutist');
    if (!flutistDir.existsSync()) {
      flutistDir.createSync(recursive: true);
    }

    // Generate content
    final content = _buildFlutistGenContent(package);

    // Write to file
    final genFile = File('$currentDir/flutist/flutist_gen.dart');
    genFile.writeAsStringSync(content);

    Logger.success('✅ Generated flutist_gen.dart');
  }

  /// Builds the content for flutist_gen.dart.
  /// flutist_gen.dart의 내용을 생성합니다.
  String _buildFlutistGenContent(Package package) {
    final buffer = StringBuffer();

    // Header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by Flutist');
    buffer.writeln();
    buffer.writeln("import 'package:flutist/flutist.dart';");
    buffer.writeln();

    // Dependencies Extension
    buffer.writeln('/// Extension for package.dependencies.xxx access');
    buffer.writeln('extension PackageDependenciesX on List<Dependency> {');

    for (final dep in package.dependencies) {
      final getterName = _toCamelCase(dep.name);
      buffer.writeln("  /// Dependency getter for ${dep.name}");
      buffer.writeln(
          "  Dependency get $getterName => firstWhere((d) => d.name == '${dep.name}');");
    }

    buffer.writeln('}');
    buffer.writeln();

    // Modules Extension
    buffer.writeln('/// Extension for package.modules.xxx access');
    buffer.writeln('extension PackageModulesX on List<Module> {');

    for (final module in package.modules) {
      final getterName = _toCamelCase(module.name);
      buffer.writeln("  /// Module getter for ${module.name}");
      buffer.writeln(
          "  Module get $getterName => firstWhere((m) => m.name == '${module.name}');");
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  // MARK: - Helper

  /// Converts string to ModuleType enum.
  /// 문자열을 ModuleType enum으로 변환합니다.
  ModuleType _parseModuleType(String typeString) {
    switch (typeString) {
      case 'feature':
        return ModuleType.feature;
      case 'library':
        return ModuleType.library;
      case 'standard':
        return ModuleType.standard;
      case 'simple':
        return ModuleType.simple;
      default:
        throw ArgumentError('Invalid module type: $typeString');
    }
  }

  /// Converts snake_case to camelCase.
  /// snake_case를 camelCase로 변환합니다.
  ///
  /// Examples:
  /// - login_example → loginExample
  /// - user_domain_implementation → userDomainImplementation
  String _toCamelCase(String snakeCase) {
    final parts = snakeCase.split('_');
    if (parts.length == 1) return snakeCase;

    final first = parts.first;
    final rest = parts.skip(1).map((part) {
      if (part.isEmpty) return part;
      return part[0].toUpperCase() + part.substring(1);
    });

    return first + rest.join('');
  }
}
